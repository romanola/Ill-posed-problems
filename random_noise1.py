# -*- coding: utf-8 -*-
"""Random_noise_experiment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k__2F8LsGpzO5QfX80FxHvtNy157JYWQ
"""

import math
from typing import Tuple, Any

import numpy as np
import scipy as sc
import matplotlib.pyplot as plt
import scipy.linalg
import statistics



def phillips(n):
    '''
    Test problem: Phillips 'famous' problem
    Disctretization of the 'famous' first-kind Fredholm integral
    equation deviced by D. L. Phillips.  Define the function
    phi(x) = | 1 + cos(x*pi/3) ,  |x| <  3 .
             | 0               ,  |x| >= 3
    Then the kernel K, the solution f, and the right-hand side
    g are given by:
    K(s,t) = phi(s-t) ,
    f(t)   = phi(t) ,
    g(s)   = (6-|s|)*(1+.5*cos(s*pi/3)) + 9/(2*pi)*sin(|s|*pi/3) .
    Both integration intervals are [-6,6].
    The order n must be a multiple of 4.
    :param n: size of matrix A
    :return: A->matrix, b->vector, x->solution-vector
    '''
    # Check input
    if n % 4 != 0:
        raise ValueError("The order n must be a multiple of 4")

    # Compute the matrix A
    h = 12 / n
    n4 = n // 4
    r1 = np.zeros(n)
    c = np.cos(np.arange(-1, n4 + 1) * 4 * np.pi / n)
    r1[:n4] = h + 9 / (h * np.pi ** 2) * (2 * c[1:n4 + 1] - c[:n4] - c[2:n4 + 2])
    r1[n4] = h / 2 + 9 / (h * np.pi ** 2) * (np.cos(4 * np.pi / n) - 1)
    A = scipy.linalg.toeplitz(r1)

    # Compute the right-hand side b
    b = np.zeros(n)
    c = np.pi / 3
    for i in range(int(n / 2), n):
        t1 = -6 + (i+1) * h
        t2 = t1 - h

        b[i] = t1 * (6 - abs(t1) / 2) + ((3 - abs(t1) / 2) * np.sin(c * t1) - 2 / c * (np.cos(c * t1) - 1)) / c - t2 * (
                    6 - abs(t2) / 2) - ((3 - abs(t2) / 2) * np.sin(c * t2) - 2 / c * (np.cos(c * t2) - 1)) / c
        b[int(n - i - 1)] = b[i]

    b = b / np.sqrt(h)


    # Compute the solution x
    x = np.zeros(n)
    a = (h + np.diff(np.sin(np.arange(0, (3 + 10 * np.finfo(float).eps), h)[:, np.newaxis] * c),
                                    axis=0) / c) / np.sqrt(h)
    x[2 * n4:3 * n4] = a.ravel()
    x[n4:2 * n4] = x[3 * n4 - 1:2 * n4 - 1:-1]

    # print(x)

    return A, b, x


def err_phillips(A, b0, x, n, nl=0.005):
    """
    Calculate the error between solution vector x and
    solution vector xr from randomized least squares problem
    :param A: matrix, size=(n, n)
    :param b0: vector, size=(1, 4)
    :param x: solution-vector, size=(4, 1)
    :param n: size of matrix A
    :param nl: noise parameter
    :return: ||x - xr||^2
    """
    epsil = nl * np.random.randn(1, n) # epsil - vector size=k, epsil_i - Normal(0, 1)
    # R = np.random.randn(n, n)
    R = np.random.normal(size=(n,n))
    b1 = b0 + epsil
    Rk = np.zeros((n, n))
    er_r = np.zeros(n)

    for k in range(n):
        Rk[k,:] = R[k,:]  # random matrix size=(k, n)
        xr = np.linalg.pinv(Rk[:k+1]@A) @ Rk[:k+1] @ b1.T
        er_r[k] = np.linalg.norm(x - xr.T, 2) ** 2

        # Er_r[k] = er_r
    return er_r


def plot_err(k_list, err_list, n, nl_list):
    """
    plot results for 1 experiment
    :param k_list: sizes of k
    :param err_list: array of errors
    :param n: size of matrix A
    :param nl_list: array with different noise levels
    :return: None
    """
    err_min_list = [ (min(err_list[i]), err_list[i].tolist().index(min(err_list[i]))+1, nl_list[i]) for i in range(len(err_list))]
    min_value = min(err_min_list)
    plt.plot(k_list, err_list[0], 'r--', label=f"min_err ={err_min_list[0][0]}, k = {err_min_list[0][1]}, nl = {nl_list[0]}")
    plt.plot(k_list, err_list[1], 'g--', label=f"min_err ={err_min_list[1][0]}, k = {err_min_list[1][1]}, nl = {nl_list[1]}")
    plt.plot(k_list, err_list[2], 'b--', label=f"min_err ={err_min_list[2][0]}, k = {err_min_list[2][1]}, nl = {nl_list[2]}")
    plt.plot(k_list, err_list[3], 'y--', label=f'min_err ={err_min_list[3][0]}, k = {err_min_list[3][1]}, nl = {nl_list[3]}')
    plt.plot(k_list, err_list[4], 'k', label=f'min_err ={err_min_list[4][0]}, k = {err_min_list[4][1]}, nl = {nl_list[4]}')
    plt.plot(k_list, err_list[5], 'b', label=f'min_err ={err_min_list[5][0]}, k = {err_min_list[5][1]}, nl = {nl_list[5]}')
    plt.xlabel('k')
    plt.ylabel('||x - xr||^2')
    plt.title(f'n = {n}, min_err = {min_value[0]}, k = {min_value[1]}, nl = {min_value[2]}')
    plt.legend()
    plt.show()



def experiments(n, nl_list, repetition=4):
    """
    plot results for repetition experiment
    :param n: size of matrix A
    :param nl_list: array with different noise levels
    :param repetition: number of experiments
    :return: None
    """
    rep = int(np.sqrt(repetition))

    fig, axes = plt.subplots(rep, rep, figsize=(20, 20))

    for i in range(rep):
        for j in range(rep):
            err_list = [err_phillips(*phillips(n), n, nl=nl_list[i]) for i in range(len(nl_list))]
            err_min_list= [(min(err_list[i]), err_list[i].tolist().index(min(err_list[i]))+1, nl_list[i]) for i in range(len(err_list))]
            k_list = list(range(1, n+1))
            min_value = min(err_min_list)
            axes[i][j].plot(k_list, err_list[0], 'r--', label=f"min_err ={err_min_list[0][0]}, k = {err_min_list[0][1]}, nl = {nl_list[0]}")
            axes[i][j].plot(k_list, err_list[1], 'g--', label=f"min_err ={err_min_list[1][0]}, k = {err_min_list[1][1]}, nl = {nl_list[1]}")
            axes[i][j].plot(k_list, err_list[2], 'b--', label=f"min_err ={err_min_list[2][0]}, k = {err_min_list[2][1]}, nl = {nl_list[2]}")
            axes[i][j].plot(k_list, err_list[3], 'y--', label=f'min_err ={err_min_list[3][0]}, k = {err_min_list[3][1]}, nl = {nl_list[3]}')
            axes[i][j].plot(k_list, err_list[4], 'k', label=f'min_err ={err_min_list[4][0]}, k = {err_min_list[4][1]}, nl = {nl_list[4]}')
            axes[i][j].plot(k_list, err_list[5], 'b', label=f'min_err ={err_min_list[5][0]}, k = {err_min_list[5][1]}, nl = {nl_list[5]}')
            axes[i][j].set_xlabel('k')
            axes[i][j].set_ylabel('||x - xr||^2')
            axes[i][j].set_title(f'n = {n}, min_err = {min_value[0]}, k = {min_value[1]}, nl = {min_value[2]}')
            axes[i][j].legend()


    plt.show()


"""----------------Section with L-curve for regularisation parameter noise level nl = 0.005----------------------"""
n = 100

A, b0, x = phillips(n)

nl = 0.005 # noise level

e = nl * np.random.randn(1, n) # noise

b = b0 + np.random.normal(size=n, scale=0.1)

# Generate regularization parameter candidates
lambda_values = np.logspace(0, 4, 100)

print(l_curve(lambda_values, A, b))
'''-----------------------------------------'''



"""-----Section for one randomisation experiment calculation------"""
NumPoints = 4 # size of a matrix A
n = NumPoints

A, b0, x = phillips(n)

nl = 0.005 # noise level
R = np.random.randn(NumPoints, NumPoints)

e = nl * np.random.randn(1, n) # noise


b1 = b0 + nl * np.random.normal(size=(1, n))

Rk = np.zeros((n, n))
er_r = np.zeros(n)

for k in range(n):
    Rk[k,:] = R[k,:]  # random matrix size=(k, n)
    xr = np.linalg.pinv(Rk[:k+1]@A) @ Rk[:k+1] @ b1.T
    er_r[k] = np.linalg.norm(x - xr.T, 2) ** 2

k = [i+1 for i in range(n)]
plt.plot(k, er_r)
plt.xlabel('k')
plt.ylabel('err')
plt.suptitle(f'n = {n}')
"""--------------------------------"""

"""----------------Section with experiment of different n and noise level nl = 0.005----------------------"""
n = [8, 12, 16, 20, 32, 56, 100, 400]  # different shapes
PLOTS_PER_ROW = 2
fig, axs = plt.subplots(4, 2, figsize=(40, 40))
p, m = 0, 0
for i in range(len(n)):
  A, b, x = phillips(n[i])  # Generate A, b, x
  err_list = err_phillips(A, b, x, n[i])  # Calculate random error ||xr - x||^2
  axs[p][m].plot([k for k in range(n[i])], err_list)
  axs[p][m].set_xlabel('k')
  axs[p][m].set_ylabel('err')
  axs[p][m].set_title(f'n = {n[i]}')
  m+=1
  if m % PLOTS_PER_ROW==0:
      p+=1
      m=0

'''-----------------------------------------'''


"""----------------Section with experiment of different n and different noise level----------------------"""
nl_list = [0.00001, 0.00005, 0.0001,  0.005, 0.01, 0.05]  # different levels of noise
n1 = 4
experiments(n1, nl_list, repetition=9)

n1 = 8
experiments(n1, nl_list, repetition=9)

n1 = 12
experiments(n1, nl_list, repetition=9)

n1 = 16
experiments(n1, nl_list, repetition=9)

n1 = 20
experiments(n1, nl_list, repetition=9)

n1 = 24
experiments(n1, nl_list, repetition=9)

n1 = 100
experiments(n1, nl_list, repetition=9)

n1 = 120
experiments(n1, nl_list, repetition=9)

n1 = 200 # рахує приблизно 20-30 секунд
experiments(n1, nl_list, repetition=9)

# n1 = 400  #рахує більше 14-ти хвилин
# experiments(n1, nl_list, repetition=9)

'''-----------------------------------------'''

