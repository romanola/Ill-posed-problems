# -*- coding: utf-8 -*-
"""Random_noise_experiment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k__2F8LsGpzO5QfX80FxHvtNy157JYWQ
"""

import math
from typing import Tuple, Any

import numpy as np
import scipy as sc
import matplotlib.pyplot as plt
import scipy.linalg
import statistics



def phillips(n):
    '''
    Test problem: Phillips 'famous' problem
    Disctretization of the 'famous' first-kind Fredholm integral
    equation deviced by D. L. Phillips.  Define the function
    phi(x) = | 1 + cos(x*pi/3) ,  |x| <  3 .
             | 0               ,  |x| >= 3
    Then the kernel K, the solution f, and the right-hand side
    g are given by:
    K(s,t) = phi(s-t) ,
    f(t)   = phi(t) ,
    g(s)   = (6-|s|)*(1+.5*cos(s*pi/3)) + 9/(2*pi)*sin(|s|*pi/3) .
    Both integration intervals are [-6,6].
    The order n must be a multiple of 4.
    :param n: size of matrix A
    :return: A->matrix, b->vector, x->solution-vector
    '''
    # Check input
    if n % 4 != 0:
        raise ValueError("The order n must be a multiple of 4")

    # Compute the matrix A
    h = 12 / n
    n4 = n // 4
    r1 = np.zeros(n)
    c = np.cos(np.arange(-1, n4 + 1) * 4 * np.pi / n)
    r1[:n4] = h + 9 / (h * np.pi ** 2) * (2 * c[1:n4 + 1] - c[:n4] - c[2:n4 + 2])
    r1[n4] = h / 2 + 9 / (h * np.pi ** 2) * (np.cos(4 * np.pi / n) - 1)
    A = scipy.linalg.toeplitz(r1)

    # Compute the right-hand side b
    b = np.zeros(n)
    c = np.pi / 3
    for i in range(int(n / 2), n):
        t1 = -6 + (i+1) * h
        t2 = t1 - h

        b[i] = t1 * (6 - abs(t1) / 2) + ((3 - abs(t1) / 2) * np.sin(c * t1) - 2 / c * (np.cos(c * t1) - 1)) / c - t2 * (
                    6 - abs(t2) / 2) - ((3 - abs(t2) / 2) * np.sin(c * t2) - 2 / c * (np.cos(c * t2) - 1)) / c
        b[int(n - i - 1)] = b[i]

    b = b / np.sqrt(h)


    # Compute the solution x
    x = np.zeros(n)
    a = (h + np.diff(np.sin(np.arange(0, (3 + 10 * np.finfo(float).eps), h)[:, np.newaxis] * c),
                                    axis=0) / c) / np.sqrt(h)
    x[2 * n4:3 * n4] = a.ravel()
    x[n4:2 * n4] = x[3 * n4 - 1:2 * n4 - 1:-1]

    # print(x)

    return A, b, x


def err_phillips(A, b0, x, n, nl=0.005):
    """
    Calculate the error between solution vector x and
    solution vector xr from randomized least squares problem
    :param A: matrix, size=(n, n)
    :param b0: vector, size=(1, 4)
    :param x: solution-vector, size=(4, 1)
    :param n: size of matrix A
    :param nl: noise parameter
    :return: ||x - xr||^2
    """
    epsil = nl * np.random.randn(1, n) # epsil - vector size=k, epsil_i - Normal(0, 1)
    # R = np.random.randn(n, n)
    R = np.random.normal(size=(n,n))
    b1 = b0 + epsil
    Rk = np.zeros((n, n))
    er_r = np.zeros(n)

    for k in range(n):
        Rk[k,:] = R[k,:]  # random matrix size=(k, n)
        xr = np.linalg.pinv(Rk[:k+1]@A) @ Rk[:k+1] @ b1.T
        er_r[k] = np.linalg.norm(x - xr.T, 2) ** 2

        # Er_r[k] = er_r
    return er_r


def l_curve(lambda_values, A, b):
    # Empty lists for values of L-curves
    residual_norms = []
    solution_norms = []

    # Parameter regularisation bruteforce
    for lmbda in lambda_values:
        # Solving the least squares problem with regularization, Tikhonov's method
        x = np.linalg.solve(A.T.dot(A) + lmbda * np.eye(A.shape[1]), A.T.dot(b))

        # Calculation of the discrepancy and solution norms
        residual = np.linalg.norm(b - A.dot(x))
        solution = np.linalg.norm(x)

        residual_norms.append(residual)
        solution_norms.append(solution)

    # The curvature of the l-curve
    curvature = np.diff(np.arctan2(residual_norms, solution_norms))

    # The maximum curvature and the corresponding regularization parameter
    idx = np.argmax(curvature)
    lambda_star = lambda_values[idx]

    # Plot of the l-curve
    plt.loglog(residual_norms, solution_norms)
    plt.scatter(residual_norms[idx], solution_norms[idx], color='red')
    plt.xlabel('Residual norm')
    plt.ylabel('Solution norm')
    plt.title('L-curve')
    plt.show()

    return lambda_star


"""----------------Section with L-curve for regularisation parameter noise level nl = 0.005----------------------"""
n = 100

A, b0, x = phillips(n)

b = b0 + np.random.normal(size=n, scale=0.1)  # vector with noise

# Generate regularization parameter candidates
lambda_values = np.logspace(0, 4, 100)

print(l_curve(lambda_values, A, b))
'''-----------------------------------------'''
